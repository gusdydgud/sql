--INSERT
--테이블 구조를 빠르게 확인하는 방법
DESC DEPARTMENTS;
--1ST
INSERT INTO DEPARTMENTS VALUES(280, 'DELVELOPER', NULL, 1700);
SELECT * FROM DEPARTMENTS;
--DML문은 트랜잭션이 항상 기록되는데, ROLLBACK이용해서 되돌릴 수 있음
ROLLBACK;

--2ND (컬럼명만 지정가능)
INSERT INTO DEPARTMENTS (DEPARTMENT_ID , DEPARTMENT_NAME , LOCATION_ID) VALUES(280,'DEVELOPER',1700);

--INSERT구문도 서브쿼리 가능(많이안씀) (단일값)
INSERT INTO DEPARTMENTS(DEPARTMENT_ID,DEPARTMENT_NAME) VALUES((SELECT MAX(DEPARTMENT_ID) + 10 FROM DEPARTMENTS),'DEV');
--INSERT구문의 서브쿼리(여러행)
CREATE TABLE EMPS AS (SELECT * FROM EMPLOYEES WHERE 1=2); --테이블 구조 복사
SELECT * FROM EMPS; --이 테이블에 원본테이블의 특정 데이터를 퍼다 나름
INSERT INTO EMPS(EMPLOYEE_ID,LAST_NAME,EMAIL,HIRE_DATE,JOB_ID)
(SELECT EMPLOYEE_ID,LAST_NAME,EMAIL,HIRE_DATE,JOB_ID FROM EMPLOYEES WHERE JOB_ID = 'SA_MAN');
DESC EMPS;
COMMIT;
----------------------------------------------------------------
--UPDATE
--업데이트 구문을 사용하기 전에는 SELECT로 해당값이 고유한 행인지 확인하고, 업데이트 처리해야합니다
UPDATE EMPS SET SALARY = 1000,COMMISSION_PCT = 0.1 WHERE EMPLOYEE_ID =148; --KEY를 조건에 적는게 일반적
UPDATE EMPS SET SALARY = NVL(SALARY,0)+1000 WHERE EMPLOYEE_ID >=145;
--업데이트구문의 서브쿼리절
--1ST(단일값 서브쿼리)
UPDATE EMPS SET SALARY = (SELECT SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID =100) WHERE EMPLOYEE_ID = 148;

--2ND(여러값 서브쿼리)
UPDATE EMPS 
SET (SALARY, COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID) = 
(SELECT SALARY,COMMISSION_PCT,MANAGER_ID,DEPARTMENT_ID FROM EMPLOYEES WHERE EMPLOYEE_ID =100)
WHERE EMPLOYEE_ID = 148;
SELECT * FROM EMPS;

--3ND(WHERE에도 됨)
UPDATE EMPS
SET SALARY =1000
WHERE EMPLOYEE_ID IN(SELECT EMPLOYEE_ID FROM EMPLOYEES WHERE JOB_ID = 'IT_PROG');

--------------------------------------------------------------------
--DELETE구문
--트랜잭션이 있긴하지만, 삭제하기전에 반드시 SELECT 문으로 삭제조건에 해당하는 데이터를 꼭 확인하는습관
SELECT * FROM EMPS WHERE EMPLOYEE_ID = 148;
DELETE FROM EMPS WHERE EMPLOYEE_ID = 148; --KEY를 통해서 지우는 편이 좋습니다
--DELETE구문도 서브쿼리 가능
DELETE FROM EMPS WHERE EMPLOYEE_ID IN (SELECT EMPLOYEE_ID FROM EMPLOYEES WHERE DEPARTMENT_ID =80);
ROLLBACK;
--------------------------------------------------------------------
--DELETE문이 전부 실행되는 것은 아님
--테이블이 연관관계(FK)제약를 가지고 있다면, 지워지지 않는다(참조무결성 제약)
SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;
DELETE FROM DEPARTMENTS WHERE DEPARTMENT_ID =100;--EMPLOYEES에서 100번 데이터를 FK로 사용하고있어서 못지움

-----------------------------------------------------------------------
--MERGE문 - 타겟테이블 데이터가 있으면 UPDATE, 없으면 INSERT구문을 수행하는 병합
--1ST
MERGE INTO EMPS A --타겟테이블
USING (SELECT * FROM EMPLOYEES WHERE JOB_ID='IT_PROG') B --합칠테이블
ON (A.EMPLOYEE_ID = B.EMPLOYEE_ID)
WHEN MATCHED THEN--일치하는경우
    UPDATE SET A.SALARY = B.SALARY,
               A.COMMISSION_PCT = B.COMMISSION_PCT,
               A.HIRE_DATE = SYSDATE
WHEN NOT MATCHED THEN--일치하지않는경우
    INSERT (EMPLOYEE_ID,LAST_NAME,EMAIL,HIRE_DATE,JOB_ID)
    VALUES (B.EMPLOYEE_ID,B.LAST_NAME,B.EMAIL,B.HIRE_DATE,B.JOB_ID);
SELECT * FROM EMPS;
--2ND -서브쿼리절로 다른테이블을 가져오는게 아니라, 직접 값을 넣을때 DUAL을쓸수있따
MERGE INTO EMPS A
USING DUAL
ON (A.EMPLOYEE_ID =107 ) --조건
WHEN MATCHED THEN --일치하면
    UPDATE SET A.SALARY = 10000,
               A.COMMISSION_PCT = 0.1,
               A.DEPARTMENT_ID = 100
WHEN NOT MATCHED THEN --일치하지않으면
    INSERT (EMPLOYEE_ID, LAST_NAME, EMAIL, HIRE_DATE, JOB_ID)
    VALUES (107,'HONG','EXAMPLE',SYSDATE,'DBA');

----------------------------------------------------------------------
DROP TABLE DEPTS;
SELECT * FROM EMPS;
--CATS - 테이블 구조 복사
CREATE TABLE EMPS AS (SELECT * FROM EMPLOYEES); --데이터까지 복사

CREATE TABLE EMPS AS (SELECT * FROM EMPLOYEES WHERE 1=2); --구조만 복사
--------------------------------------------------------------------
--1
CREATE TABLE DEPTS AS (SELECT * FROM DEPARTMENTS);
SELECT * FROM DEPTS;
ROLLBACK;
DESC DEPTS;
INSERT INTO DEPTS VALUES(320,'영업',303,1700);
--2
UPDATE DEPTS SET DEPARTMENT_NAME = 'IT BANK' WHERE DEPARTMENT_NAME='IT Support';
UPDATE DEPTS SET MANAGER_ID = 301 WHERE DEPARTMENT_ID =290;
UPDATE DEPTS SET DEPARTMENT_NAME='IT HELP',
                 MANAGER_ID = 303,
                 LOCATION_ID = 1800
WHERE DEPARTMENT_NAME = 'IT Helpdesk';
--3
DELETE FROM DEPTS WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID FROM DEPTS WHERE DEPARTMENT_NAME='영업');
DELETE FROM DEPTS WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID FROM DEPTS WHERE DEPARTMENT_NAME='NOC');
--4
DELETE FROM DEPTS WHERE DEPARTMENT_ID > 200;
UPDATE DEPTS SET MANAGER_ID =100 WHERE MANAGER_ID IS NULL;
--Departments테이블은 매번 수정이 일어나는 테이블이라고 가정하고 
--Depts와 비교하여
----일치하는 경우 Depts의 부서명, 매니저ID, 지역ID를 업데이트 하고, 
--새로유입된 데이터는 그대로 추가해주는 merge문을 작성하세요.
MERGE INTO DEPTS A
USING DEPARTMENTS D
ON (A.DEPARTMENT_ID = D.DEPARTMENT_ID)
WHEN MATCHED THEN
    UPDATE SET A.DEPARTMENT_NAME = D.DEPARTMENT_NAME,
               A.MANAGER_ID = D. MANAGER_ID,
               A.LOCATION_ID = D.LOCATION_ID
WHEN NOT MATCHED THEN
    INSERT (DEPARTMENT_NAME,MANAGER_ID,LOCATION_ID)
    VALUES (D.DEPARTMENT_NAME,D.MANAGER_ID,D.LOCATION_ID);

--5
SELECT * FROM JOBS;
CREATE TABLE JOBS_IT AS(SELECT * FROM JOBS WHERE MIN_SALARY>= 6000);
SELECT * FROM JOBS_IT;
INSERT INTO JOBS_IT VALUES('SEC_DEV','보안개발팀',6000,19000);
--jobs테이블은 매번 수정이 일어나는 테이블이라고 가정하고 jobs_it과 비교하여
--min_salary컬럼이 0보다 큰 경우 기존의 데이터는 min_salary, max_salary를 
--업데이트 하고 새로 유입된
--데이터는 그대로 추가해주는 merge문을 작성하세요.
MERGE INTO JOBS_IT A
USING JOBS B
ON (A.JOB_ID = B.JOB_ID)
WHEN MATCHED THEN
    UPDATE SET A.MIN_SALARY = B.MIN_SALARY,
               A.MAX_SALARY = B.MAX_SALARY 
    WHERE B.MIN_SALARY >=0
WHEN NOT MATCHED THEN
    INSERT (JOB_ID,MIN_SALARY,MAX_SALARY)
    VALUES (B.JOB_ID,B.MIN_SALARY,B.MAX_SALARY);






